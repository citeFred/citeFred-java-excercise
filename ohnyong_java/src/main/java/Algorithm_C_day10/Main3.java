package Algorithm_C_day10;
/*바이러스
* 시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
1 초	128 MB	158769	73525	49465	45.834%
문제
신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다.
* 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.

예를 들어 7대의 컴퓨터가 <그림 1>과 같이 네트워크 상에서 연결되어 있다고 하자.
* 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐
* 3번과 6번 컴퓨터까지 전파되어 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다.
* 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다.
*

1-2-3
|/
5-6

4-7

어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다.
* 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때,
*  1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.

입력
첫째 줄에는 컴퓨터의 수가 주어진다.
* 컴퓨터의 수는 100 이하인 양의 정수이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다.

출력
1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.

예제 입력 1
7
6
1 2
2 3
1 5
5 2
5 6
4 7
예제 출력 1
4*/

// 알고리즘 관련 정리 잘된 블로그
// https://limkydev.tistory.com/93

// DFS, BFS를 통한 풀이
// https://zzang9ha.tistory.com/40

//https://bagbokman.tistory.com/24
//그래프에서 중요한 것은 각 문제별로 어떤 특징을 가진 그래프인지 알고 해당 그래프의 특성에 맞게 잘 자료구조로 나타낸다음?
// 문제에서 원하는 답을 도출할 수 있도록 순회를 해서 답을 내는 것

//문제 푸는 법
//원하는 답이 뭔지를 보자 -> 바이러스에 걸리게 되는 컴퓨터의 수를 구하라는 것 -> 그래프에서 1번 노드와 연결되어있는 노드의 수를 세면 된다.
//단순히 연결되어있는 애들을 보는 것이기 때문에 순회 방법은 크게 상관이 없다. -> 어려운 문제에선 상관이 있겠구나라는것만 인지하자
//단순한 문제이기 때문에 그래프를 인접행렬로 구현할지 인접리스트로 구현할지는 상관이 없다. -> 어려운 문제에선 상관이 있겠구나라는것을 인지하자
//그래프는 무방향 그래프이구나 라는 것만 챙겨가면 되겠다. -> 그래프의 종류들이 달라질 수 있구나라는 것을 인지하자

// 코드 1(인접행렬, DFS)
import java.util.Scanner;

public class Main3 {
    static int map[][];
    static boolean visit[];
    static int n, m, v;
    static int count = 0;

    public static int dfs(int i) {
        visit[i] = true;

        for(int j=1; j<=n; j++) {
            if(map[i][j] == 1 && visit[j] == false) {
                count ++;
                dfs(j);
            }
        }
        return count;
    }

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        n = scan.nextInt();	// 컴퓨터 수(정점)
        m = scan.nextInt();	// 연결된 컴퓨터 쌍의 수(간선)
        v = 1;	// 탐색 시장할 정점의 번호
        map = new int[n+1][n+1];	// 각 정점간 탐색 경로를 저장할 배열
        visit = new boolean[n+1];	// 정점의 탐색 여부 체크

        for(int i=0; i<m; i++) {
            int a = scan.nextInt();
            int b = scan.nextInt();
            map[a][b] = map[b][a]= 1;
        }

        System.out.println(dfs(1));
        scan.close();
    }
}

